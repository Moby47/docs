{"componentChunkName":"component---src-templates-docs-js","path":"/reference/arcql","result":{"data":{"site":{"siteMetadata":{"title":"Hypi Documentation","docsLocation":"https://github.com/hypi-universe/docs/tree/master/content"}},"mdx":{"fields":{"id":"a7a6e61a-7876-5122-9f4f-0beab4ce956f","title":"ArcQL Filtering","slug":"/reference/02-arcql"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"ArcQL Filtering\",\n  \"metaTitle\": \"Hypi tutorial for ArcQL\",\n  \"metaDescription\": \"How to find data in the Hypi platform using ArcQL\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Introduction\"), mdx(\"p\", null, \"A SQL-like query language used to filter, sort and paginate data in the platform.\\nHypi offers a powerful query language as part of its platform.\"), mdx(\"p\", null, \"ArcQL is modelled off of the Apache Lucene query language. We went further and included some SQL like features e.g. SORT, FROM, LIMIT.\"), mdx(\"h2\", null, \"Query Structure\"), mdx(\"p\", null, \"\\u200CArcQL is made up of four major components.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<query> <sort> <from> <limit>\"), \"  i.e. it is very SQL like. Designed intentionally so to help make the learning curve as small as possible for our developers.\\nIf you\\u2019re familiar with SQL or the Lucene query language you\\u2019ll probably be able to write ArcQL queries by just guessing at it.\\n\\u200CLet\\u2019s break the four components down but leave query for last since it is the most complex.\"), mdx(\"h3\", null, \"ArcQL Pagination\"), mdx(\"p\", null, \"For specifying a paging token\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FROM 'some token'\"), \"  this is all there is to it. When you search, every object returned by the API includes their paging token in the special hypi field.\\nTake the token from the last object we returned to you and pass it back. We will then send back results after this object.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Examples:\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"${_arcql} LIMIT ${limit} FROM ${fromToken}\")), mdx(\"h3\", null, \"ArcQL: Sorting\"), mdx(\"p\", null, \"For specifying how to sort matching results\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Examples:\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{arcql: fieldName SORT hypi.created ASC|DES}\\u200C\"), \"                       \"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"SORT a\"), \"  \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"SORT a ASC\"), \" \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"SORT a DESC\"), \" \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"SORT a, b.c DESC, c\"))), mdx(\"h3\", null, \"ArcQL Limiting\"), mdx(\"p\", null, \"For limiting the number of results returned, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LIMIT 50\"), \"  this is all there is to it, when you search we will impose a max limit the query, currently \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"100\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Examples:\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"${_arcql} LIMIT ${limit}\"), \"                      \"), mdx(\"h3\", null, \"ArcQL Term Query\"), mdx(\"p\", null, \"A term query is a simple filter asking to return results that match the value provided exactly. Examples:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"a = 'some string'\\na = 123\\na = 'some string' OR 123 AND 'abc'\\n\")), mdx(\"p\", null, \"\\u200CBoolean Logic is possible on all query types. The general form is as demonstrated on line 3 (the last example). The last example says \\u201Creturn objects where field a is\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"some string\"), \" or where a is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"123\"), \"  \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AND\"), \" a is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"abc\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This query is non-sensical because and will only return objects that have a set to  \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"abc\"), \".  \\u200CThe reason for this is that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AND\"), \" is treated as an absolute assertion requiring that the given field \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MUST\"), \"  have the requested value in order for it to match. \")), mdx(\"h3\", null, \"ArcQL Phrase Query\"), mdx(\"p\", null, \"A phrase query is similar to what an end user might expect a search engine to do. You search for  \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"New York\"), \" it will return objects containing this exact phrase or the individual words.\"), mdx(\"p\", null, \" \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Example\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fieldName ~ '${query}' OR fieldName ~ '${query}' OR fieldName ~ '${query}' fieldName ~  '${query}'\"), \";\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"a ~ 'some string'\\n \\na ~ 123\\n \\na ~ 'some string' OR 123\\n\")), mdx(\"br\", null), mdx(\"br\", null), mdx(\"h3\", null, \"ArcQL EXIST\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Example\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"EXIST a\"), \"\\nThis asserts that the field \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" exists i.e. only data where the field exists will match\"), mdx(\"h3\", null, \"ArcQL NOT EXIST\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Example\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NOT EXIST b\"), \"\\nThis asserts that the field \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \" does \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" exist i.e. only data where the field does NOT exist will match\"), mdx(\"h3\", null, \"ArcQL Prefix Query\"), mdx(\"p\", null, \"A prefix query will take the terms you\\u2019ve searched for and match any object where the contents of the field starts with those terms\\na ^ 'some string'\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"a ^ 123\\n \\na ^ 'some string' OR 123\\n\")), mdx(\"h3\", null, \"ArcQL Wildcard Query\"), mdx(\"p\", null, \"A wildcard query takes the terms searched for and treats  \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"?\"), \" as special characters.\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"*\"), \" Means match anything from this point onwards\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"?\"), \" Means match any single character at this position \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"a * 'some' \\n \\na * 123 \\n \\na * 'some?str*' OR 123  \\n\")), mdx(\"div\", null), mdx(\"br\", null), mdx(\"h3\", null, \"ArcQL Fuzzy Query\"), mdx(\"p\", null, \"A fuzzy query takes the terms searched for and tries to match words that are similar even if spelt slightly differently e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tame\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"game\"), \"  would match if you searched for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tame\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"~ a ~ 'some string'\\n \\n~ a ~[1] 'some string' OR 'other string'\\n \\n~ a ~[1,5] 'some string' OR 'other string'\\n \\n~ a ~[1,5,10] 'some string' OR 'other string'\\n \\n~ a ~[1,5,10,true] 'some string' OR 'other string'\\n\")), mdx(\"p\", null, \"The numbers and the boolean all you to tweak how the fuzzy algorithm runs. The parameters are \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1. max edits\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2. prefix length\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \" 3. max expansion\"), \"  \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"4. allow transpositions\"), \"  In that order.\"), mdx(\"h3\", null, \"ArcQL Range Query\"), mdx(\"p\", null, \"\\u200CRange queries are a means for you to search for content that falls within the given range.\\na IN [0, 1)\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"a IN (0, 1]\\n \\na IN (0, 1)\\n \\na IN [0, 1]\\n \\n//any of the above can also use boolean logic e.g.\\n \\na IN [0, 1 OR 5,10 AND 10, 11)\\n \\n \\n \\n//all of the above also works for strings\\n \\na IN ['America', 'Jamaica')\\n\")), mdx(\"p\", null, \"These are the standard mathematical representations of ranges and work exactly as you\\u2019d expect i.e.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[0,1)\"), \" left inclusive, i.e. including 0, excluding 1 \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"(0,1]\"), \" right inclusive, i.e. excluding 0, including 1\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"(0,1)\"), \" exclusive, i.e. not including 0 or 1, only those between\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[0,1]\"), \" inclusive, i.e. including both 0, 1 and everything in between\")), mdx(\"h3\", null, \"ArcQL Match All Query\"), mdx(\"p\", null, \"A match all query is simple a query with the value *, it will return all documents unless other filters restrict it.\\n\\u200C\\u200CCombining the various queries work as expected\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"(a = 'something' OR b ~ 'New York') AND (c ^ 'alpha' OR ~d~ \\\"something\\\" OR a IN [0,10))\")), mdx(\"h3\", null, \"ArcQL REF FROM\"), mdx(\"p\", null, \"\\u200CHypi is a polyglot storage service, one of the supported storage paradigms is for graph data, see the API Guide for more information. ArcQL has support for querying graph data.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"REF FROM '<Origin Type>' ON '<Origin Field>' FOR '<Origin ID>' WHERE <ArcQL filter>\")), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"\\u200COrigin Type\"), \" is the name of the GraphQL type from which you would like to find edges\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Origin Field\"), \" is the name of the field on the Origin Type for which the edge exists\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Origin ID\"), \" is the ID of the object/vertex to find references from\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ArcQL filter\"), \" is any valid ArcQL query, this is optional and if present will only return edges that match\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#introduction","title":"Introduction"},{"url":"#query-structure","title":"Query Structure","items":[{"url":"#arcql-pagination","title":"ArcQL Pagination"},{"url":"#arcql-sorting","title":"ArcQL: Sorting"},{"url":"#arcql-limiting","title":"ArcQL Limiting"},{"url":"#arcql-term-query","title":"ArcQL Term Query"},{"url":"#arcql-phrase-query","title":"ArcQL Phrase Query"},{"url":"#arcql-exist","title":"ArcQL EXIST"},{"url":"#arcql-not-exist","title":"ArcQL NOT EXIST"},{"url":"#arcql-prefix-query","title":"ArcQL Prefix Query"},{"url":"#arcql-wildcard-query","title":"ArcQL Wildcard Query"},{"url":"#arcql-fuzzy-query","title":"ArcQL Fuzzy Query"},{"url":"#arcql-range-query","title":"ArcQL Range Query"},{"url":"#arcql-match-all-query","title":"ArcQL Match All Query"},{"url":"#arcql-ref-from","title":"ArcQL REF FROM"}]}]},"parent":{"__typename":"File","relativePath":"reference/02-arcql.md"},"frontmatter":{"metaTitle":"Hypi tutorial for ArcQL","metaDescription":"How to find data in the Hypi platform using ArcQL"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/404","title":"Page Not Found"}}},{"node":{"fields":{"slug":"/","title":"Hypi Platform Documentation"}}},{"node":{"fields":{"slug":"/introduction","title":"Introduction to Hypi"}}},{"node":{"fields":{"slug":"/recipes","title":"Recipes"}}},{"node":{"fields":{"slug":"/products","title":"Products"}}},{"node":{"fields":{"slug":"/tutorials","title":"Tutorials"}}},{"node":{"fields":{"slug":"/reference/00-instance","title":"Instances"}}},{"node":{"fields":{"slug":"/tutorials/01-registration-and-login","title":"Registration & Login"}}},{"node":{"fields":{"slug":"/reference/04-graph","title":"Graph Queries"}}},{"node":{"fields":{"slug":"/reference","title":"Reference"}}},{"node":{"fields":{"slug":"/recipes/01-login","title":"Logging into a Hypi app"}}},{"node":{"fields":{"slug":"/reference/01-graphql","title":"GraphQL"}}},{"node":{"fields":{"slug":"/reference/02-arcql","title":"ArcQL Filtering"}}},{"node":{"fields":{"slug":"/recipes/02-create-account","title":"Create an account"}}},{"node":{"fields":{"slug":"/recipes/03-build-todo-app","title":"Build a todo app"}}},{"node":{"fields":{"slug":"/products/00-axiom","title":"Axiom"}}},{"node":{"fields":{"slug":"/products/01-api-gateway","title":"API Gateway"}}},{"node":{"fields":{"slug":"/products/03-analytics","title":"Analytics"}}},{"node":{"fields":{"slug":"/products/02-iot","title":"IoT"}}},{"node":{"fields":{"slug":"/reference/04-authorisation/01-permissions","title":"Permissions"}}},{"node":{"fields":{"slug":"/reference/01-graphql/01-intro","title":"Introduction"}}},{"node":{"fields":{"slug":"/reference/04-authorisation/02-policies","title":"Policies"}}},{"node":{"fields":{"slug":"/reference/01-graphql/02-query","title":"Queries"}}},{"node":{"fields":{"slug":"/reference/01-graphql/04-subscription","title":"Subscriptions"}}},{"node":{"fields":{"slug":"/reference/01-graphql/05-hypi-object","title":"Magic Hypi Object"}}},{"node":{"fields":{"slug":"/reference/01-graphql/03-mutation","title":"Mutations"}}},{"node":{"fields":{"slug":"/reference/01-graphql/06-directives","title":"Directives"}}},{"node":{"fields":{"slug":"/reference/01-graphql/07-interfaces","title":"Interfaces"}}},{"node":{"fields":{"slug":"/products/00-axiom/00-api","title":"API Setup"}}},{"node":{"fields":{"slug":"/products/00-axiom/01-app","title":"Apps"}}},{"node":{"fields":{"slug":"/products/00-axiom/03-math-api","title":"Math API"}}},{"node":{"fields":{"slug":"/products/00-axiom/06-user-defined-functions","title":"User Defined Functions"}}},{"node":{"fields":{"slug":"/products/00-axiom/07-serverless-functions","title":"Serverless functions"}}},{"node":{"fields":{"slug":"/products/00-axiom/08-triggers","title":"Triggers"}}},{"node":{"fields":{"slug":"/products/00-axiom/07-workflow","title":"Workflows"}}},{"node":{"fields":{"slug":"/products/00-axiom/09-webhooks","title":"Webhooks"}}},{"node":{"fields":{"slug":"/FAQs","title":"FAQs"}}},{"node":{"fields":{"slug":"/tutorials/03-crud","title":"Hypi GraphQL CRUD Tutorial"}}},{"node":{"fields":{"slug":"/products/00-axiom/02-crud","title":"CRUD"}}},{"node":{"fields":{"slug":"/products/00-axiom/04-aggregations-api","title":"Aggregations API"}}},{"node":{"fields":{"slug":"/products/00-axiom/10-permission-and-authorisation","title":"Authorisation"}}},{"node":{"fields":{"slug":"/tutorials/04-dateGranularity","title":"Timeseries Aggregations with Date Granularity"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"a7a6e61a-7876-5122-9f4f-0beab4ce956f"}}}