{"componentChunkName":"component---src-templates-docs-js","path":"/reference/authorisation","result":{"data":{"site":{"siteMetadata":{"title":"Hypi Documentation","docsLocation":"https://github.com/hypi-universe/docs/tree/master/content"}},"mdx":{"fields":{"id":"cd0674e2-bc04-5336-aa47-c91d3f84ce00","title":"Authorisation","slug":"/reference/authorisation"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Authorisation\",\n  \"metaTitle\": \"Hypi tutorial introducing authorisation\",\n  \"metaDescription\": \"Introduction to application instance authorisation on the Hypi platform\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Introduction\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Authorization\"\n  }), \"Authorisation\"), \" is the process which leads to a decision of whether access should be allowed or denied. In classic authorisation models there is a triple consisting of subject, object and action. For the most part, Hypi keeps these but enhances them a bit.\"), mdx(\"p\", null, \"Authorisation depends on checking whether an \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Authentication\"\n  }), \"authenticated\"), \" subject is allowed by the available Permissions to access some resource (the object). Hypi's authorisation model is similar to but is not a compliant implementation of user\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/User-Managed_Access\"\n  }), \"managed access control\"), \" /UMA.\"), mdx(\"h2\", null, \"Concepts\"), mdx(\"p\", null, \" There are some concepts involved in Authorisation:\"), mdx(\"h3\", null, \"Subject\"), mdx(\"p\", null, \"A subject is the entity trying to perform an action or gain access to a resource.\\nResource or Object\\nA resource or object is the thing being protected. In Hypi, there are three primary things that can be protected.\"), mdx(\"p\", null, \"\\u200B1. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Resource\"), \" - any object that exists in the Hypi platform\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"\\u200B2. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Scope\"), \" - Any GraphQL field OR any arbitrary URI\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"\\u200B3. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Type\"), \" - Any GraphQL field\"), mdx(\"h3\", null, \"Policy\"), mdx(\"p\", null, \" A policy encapsulates two important pieces of information, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"subject\"), \" in authorisation and whether access should be granted or denied i.e. the logic. There are a number of policies depending on the subject that Hypi supports. One of the main purposes of a policy is to promote re-use. Policies are intended to be created and re-used so that they can be kept as simple as possible. Where necessary, an AggregatePolicy can be used to group multiple policies.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"GroupPolicy\"), \" - A group policy applies to list the list of Accounts or Organisations in the groups the policy links to.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RolePolicy\"), \" - A role policy applies to a list of Roles.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"AccountPolicy\"), \" - Applies to a set of Accounts.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RealmPolicy\"), \" - Applies to a set of Realms.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TimePolicy\"), \" - Allows granting or denying access based on date or time\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ClientPolicy\"), \" - Controls access based on the client used to access a resource\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"AggregatePolicy\"), \" - allows grouping one or more policies\")), mdx(\"h3\", null, \"\\u200BPermission\\u200B\"), mdx(\"p\", null, \"A permission encapsulates the object involved in authorisation.  \"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"\\u200C\\u200BResource Based\"), \" - Allows protecting a specific resource by ID  \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Scope Based\"), \" - Allows protecting either a GraphQL field or an arbitrary URI pattern  \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Type Based\"), \" - Allows protecting a GraphQL type\")), mdx(\"h3\", null, \"Policy decision point or PDP\"), mdx(\"p\", null, \"PDP is an internal implementation detail but is worth being aware of, it is the thing that brings permissions and policies together to make a decision as to whether an action should be allowed or denied.\"), mdx(\"p\", null, \"\\u200C1. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Creating a new object\"), \", the entity graph will use the PEP to ensure that the subject can call the create function i.e.\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"the subject has access to the Mutation:create<type> scope\"), \"  \"), mdx(\"p\", null, \"2.\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Updating an existing object\"), \", the entity graph will use the PEP to ensure that the subject has access to the object                                               \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If no scope based permission exist that applies to the object then access to the object implies access on all scopes\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If a scope based permission exist which applies to the object then the entity graph verifies that the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Mutation:update<type>\"), \" scope for the object grants access otherwise the update is not allowed\")), mdx(\"p\", null, \"3.\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Searching with ArcQL\"), \", an object is only included in search results if the subject making the query is allowed to see the object.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"If no scope based permission exist that applies to the object then access to the object implies access on all scopes\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"If a scope based permission exist which applies to the object then the entity graph verifies that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Query:find<type>\"), \" scope for the object grants access otherwise the search is not allowed\"))), mdx(\"p\", null, \"4.\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Custom GraphQL function\"), \", Hypi's GraphQL instrumentation uses the PEP to verify that the subject is granted access to the scope before evaluating the custom function. It verifies\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \" Query:<customFunctionName>\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Mutation:<customFunctionName>\"), \" grants access. It is recommended that one scope based permission be used to contain multiple scopes since all scopes in the realm that are not resource specific must be evaluated to see if the apply. This means more scope scope based permissions potentially impacts performance.\"), mdx(\"h3\", null, \"Policy administration point or PAP\"), mdx(\"p\", null, \"PAP is an internal implementation detail which controls which subjects get to operate on authorisation policies. It is the quintessential answer to the question of \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Quis_custodiet_ipsos_custodes%3F\"\n  }), \"\\\"Who will guard the guards themselves?\\\"\"), \". The PAP's job is to ensure that only the subjects that are allowed, can actually change the authorisation policies in the system. In a nutshell policies are treated like other resources to access them, a subject must be the creator or has had a policy created by an authorised subject which grants them access. The rules for authorisation requests are expounded below.\"), mdx(\"h2\", null, \"Authorisation Requests\"), mdx(\"p\", null, \"As already mentioned there are three things that can be protected types, scopes and resources, depending on what's being done a different authorisation request is generated.\"), mdx(\"h3\", null, \"Creating a resource\"), mdx(\"p\", null, \"Creating a resource requires that either no scope based permission exist that applies to the type of resource being created or that at least one exists which grants permission on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Mutation:create<type>\"), \" scope.\"), mdx(\"h3\", null, \"Update, Delete and Trash, Link and Unlinking a resource\"), mdx(\"p\", null, \"All of these operate on existing resources and as such generates an authorisation request which can type, scope and/or resource based permissions.\"), mdx(\"h3\", null, \"\\u200CSearching for resources\"), mdx(\"p\", null, \"The platform uses \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/reference/02-arcql\"\n  }), \"ArcQL\"), \" for finding data. All requests to get data, no matter how trivial the query, goes through ArcQL. During a search, resources that match that search are further filtered down to only those that the subject is allowed to see. The query engine uses the PEP to check if the subject can see the resource and if it says no then the resource is not included in the matching resources.\"), mdx(\"h3\", null, \"Evaluation of authorisation requests\"), mdx(\"p\", null, \"Evaluation follows a series of rules that may not necessarily be intuitive at first. In the first place, we allow multiple permissions to be defined that affects the same object. When this happens, there is a default decision strategy that applies to the entire Realm. This is used to resolve ambiguity, if not explicitly set, it defaults to Unanimous, meaning all must grant access.\"), mdx(\"p\", null, \"First, permission types are prioritised (most important first)\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"/reference/04-authorisation/01-permissions\"\n  }), \"ResourceBasedPermission\"), \"   \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"/reference/04-authorisation/01-permissions\"\n  }), \"ScopeBasedPermission\"), \"     \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"/reference/04-authorisation/01-permissions\"\n  }), \"TypeBasedPermission\"), \"   \")), mdx(\"p\", null, \"This means that if an object has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ResourceBasedPermission\"), \", it overrides \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ScopeBasedPermission\"), \" which in turn overrides \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeBasedPermission\"), \".\\nRegardless of the type of \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/reference/04-authorisation/01-permissions\"\n  }), \"Permission\"), \" , there are two explicit cases and one implicit.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Any permission that has no policy attached results in a permission denied for any object the permission would otherwise apply to.\")), mdx(\"h3\", null, \"Implicit Permission\"), mdx(\"p\", null, \"If no \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ResourceBasedPermission\"), \" exist, one is implicitly created with an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AccountPolicy\"), \" which grants access to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Account\"), \" which created the object.\"), mdx(\"p\", null, \"\\u200C\\nIf there is a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ResourceBasedPermission\"), \", an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AccountPolicy\"), \" is added to it which grants access to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Account\"), \" which created the resource. This behaviour means that by default a resource is always accessible to the Account which created it.\"), mdx(\"p\", null, \"\\u200C\\nIf an administrator would like to prevent the creator of a resource from accessing it then a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ResourceBasedPermission\"), \" MUST be explicitly created AND it should use the \\\"Unanimous\\\" decision strategy to result in a permission denied for the creator\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"We recommend always creating a resource based permission for every object. Scope and type based permissions are very good for creating broad policies but are easier to get wrong when building complex authorisation scenarios.\")), mdx(\"h3\", null, \"Explicit Permission\"), mdx(\"p\", null, \"When only a single permission exists that applies to an object, there can be no ambiguity since the \\\"decision strategy\\\" is used to resolve any such case within the permission.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Multiple permission rules\"), \"\\nThe problem with multiple permissions that apply to the same resource is ambiguity. The platform's approach to resolving ambiguity is to use the global realm level decision strategy.\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"These rules apply IF AND ONLY IF there are multiple permissions that apply.\")), mdx(\"p\", null, \"\\u200C\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Resource based authorisation requests\"), \",\\nWhen an authorisation request is made for a specific resource any \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ResourceBasedPermission\"), \" that exist this implies access for the types and scopes on that resource (whether the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ResourceBasedPermission\"), \" was implicit or explicitly created. This means that any \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ScopeBasedPermission\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeBasedPermission\"), \" that may otherwise have applied will be ignored.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Scope & Type based authorisation requests\"), \",\\nWhen the authorisation request is either scope or type based permission is implicitly granted if no explicit permission exists of those types. If at least one scope or type based permission is available that applies then they are used to determine if access is granted or denied. Note this is contrary to resource based authorisation requests since there is always at least one resource based policy.\\n\\u200C\\u200C\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#introduction","title":"Introduction"},{"url":"#concepts","title":"Concepts","items":[{"url":"#subject","title":"Subject"},{"url":"#policy","title":"Policy"},{"url":"#permission","title":"​Permission​"},{"url":"#policy-decision-point-or-pdp","title":"Policy decision point or PDP"},{"url":"#policy-administration-point-or-pap","title":"Policy administration point or PAP"}]},{"url":"#authorisation-requests","title":"Authorisation Requests","items":[{"url":"#creating-a-resource","title":"Creating a resource"},{"url":"#update-delete-and-trash-link-and-unlinking-a-resource","title":"Update, Delete and Trash, Link and Unlinking a resource"},{"url":"#searching-for-resources","title":"‌Searching for resources"},{"url":"#evaluation-of-authorisation-requests","title":"Evaluation of authorisation requests"},{"url":"#implicit-permission","title":"Implicit Permission"},{"url":"#explicit-permission","title":"Explicit Permission"}]}]},"parent":{"__typename":"File","relativePath":"reference/03-authorisation.md"},"frontmatter":{"metaTitle":"Hypi tutorial introducing authorisation","metaDescription":"Introduction to application instance authorisation on the Hypi platform"}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/recipes","title":"Recipes"}}},{"node":{"fields":{"slug":"/introduction","title":"Introduction to Hypi"}}},{"node":{"fields":{"slug":"/","title":"Hypi Platform Documentation"}}},{"node":{"fields":{"slug":"/reference","title":"Reference"}}},{"node":{"fields":{"slug":"/tutorials/creating-apps","title":"Creating an app"}}},{"node":{"fields":{"slug":"/tutorials/registration-and-login","title":"Registration & Login"}}},{"node":{"fields":{"slug":"/tutorials","title":"Tutorials"}}},{"node":{"fields":{"slug":"/reference/instance","title":"Instances"}}},{"node":{"fields":{"slug":"/reference/graphql","title":"GraphQL"}}},{"node":{"fields":{"slug":"/reference/arcql","title":"ArcQL Filtering"}}},{"node":{"fields":{"slug":"/reference/graph","title":"Graph Queries"}}},{"node":{"fields":{"slug":"/recipes/login","title":"Logging into a Hypi app"}}},{"node":{"fields":{"slug":"/reference/realtime","title":"Realtime"}}},{"node":{"fields":{"slug":"/recipes/create-account","title":"Create an account"}}},{"node":{"fields":{"slug":"/reference/instance/custom-functions","title":"Custom Functions"}}},{"node":{"fields":{"slug":"/reference/instance/crud","title":"CRUD"}}},{"node":{"fields":{"slug":"/recipes/build-todo-app","title":"Build a todo app"}}},{"node":{"fields":{"slug":"/reference/instance/monitoring","title":"Logs"}}},{"node":{"fields":{"slug":"/reference/instance/logs","title":"Monitoring"}}},{"node":{"fields":{"slug":"/reference/authorisation/permissions","title":"Permissions"}}},{"node":{"fields":{"slug":"/reference/authorisation/policies","title":"Policies"}}},{"node":{"fields":{"slug":"/reference/graphql/intro","title":"Introduction"}}},{"node":{"fields":{"slug":"/reference/graphql/query","title":"Queries"}}},{"node":{"fields":{"slug":"/reference/graphql/mutation","title":"Mutations"}}},{"node":{"fields":{"slug":"/reference/graphql/subscription","title":"Subscriptions"}}},{"node":{"fields":{"slug":"/reference/graphql/hypi-object","title":"Magic Hypi Object"}}},{"node":{"fields":{"slug":"/reference/graphql/directives","title":"Directives"}}},{"node":{"fields":{"slug":"/reference/graphql/interfaces","title":"Interfaces"}}},{"node":{"fields":{"slug":"/FAQs","title":"FAQs"}}},{"node":{"fields":{"slug":"/reference/authorisation","title":"Authorisation"}}},{"node":{"fields":{"slug":"/404","title":"Page Not Found"}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"cd0674e2-bc04-5336-aa47-c91d3f84ce00"}}}